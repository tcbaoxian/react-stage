# 项目结构划分

```
├── /book/           # 整理页面逻辑
├── /build/          # npm run build生成的压缩代码
├── /server/         # 服务器端代码，主要放一些本地测试的模拟接口数据
│ ├── /public/       # 服务器的静态资源，比如JS、CSS、json
│ ├── /view/         # 服务器端的页面输出
│ ├── /app.js        # 服务器的入口，可以配置服务器的路由
├── /src/            # 项目源码目录
│ ├── /actions/      # 每个页面的actions
│ ├── /components/   # 每个页面的页面结构和组件
│ ├── /config/       # 公共的配置信息，比如异步地址
│ ├── /containers/   # 公共头部
│ ├── /reducers/     # 每个页面的reducers
│ ├── /root/         # 页面根路径和react-router路由
│ ├── /store/        # 
├── package.json     # 项目信息
└── README.md        # 数据mock配置
```

#　Redux的工作流程

```
  ╔═════════╗       ╔════════╗       ╔═════════════════╗
  ║ Actions ║──────>║ Stores ║──────>║ View Components ║
  ╚═════════╝       ╚════════╝       ╚═════════════════╝
       ^                                      │
       └──────────────────────────────────────┘
```

大致的过程是这样的，View层不能直接对state进行操作，而需要依赖Actions派发指令来告知Store修改状态，Store接收Actions指令后发生相应的改变，View层同时跟着Store的变化而变化。

举个例子：A组件要使B组件发生变化。首先，A组件需要执行一个Action，告知绑定B组件的Store发生变化，Store接收到派发的指令后改变，那相应的B组件的视图也就发生了改变。假如C，D，E，F组件绑定了和B组件相同的Store，那么C，D，E，F也会跟着变化。

所以我们需要关心的就是三个部分：视图View、派发指令Actions和绑定的数据Store。

# 视图View


# 派发指令Actions


# 绑定的数据Store








